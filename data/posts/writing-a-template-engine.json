{"writing-a-template-engine":{"title":"Writing a template engine is hard","body":"<p>When I set out to write the <a href=&quot;/breadbox&quot;>Breadbox</a> framework, the thing I was most excited about was writing my own template engine. Now, six months later, I can&apos;t express just how naive that excitement was. Not only did I not know what I was doing, but I had a grave misunderstanding of the limitations of regex in JavaScript which would send me down a path that ultimately let to me <code>rm -rf</code>ing 5 months of work (that&apos;s deleting for any non bashers out there).</p>\r\n\r\n<p>There&apos;s one thing I was right about. The template engines available for Node today kind of suck. Pretty much all of them have weird arbitrary syntax requirements. Some of the most developer-friendly ones are also the slowest. And some are okay for developers but totally alien for designers. I haven&apos;t solved that last one yet, but at this point I&apos;ll settle for 2 out of 3 goals.</p>\r\n\r\n<h1>The blank slate</h1>\r\n\r\n<p>In the beginning, it was fun. It started with this:</p>\r\n\r\n<pre class=&quot;language-html&quot;><code>hello {{test}}</code></pre>\r\n\r\n<p>Then, with a simple regex, I wrote a function that would get the template and spit out this:</p>\r\n\r\n<pre class=&quot;language-html&quot;><code>hello world</code></pre>\r\n\r\n<p><em>&quot;Woohoo! I&apos;m a genious! I can&apos;t believe people make this sound so hard!</em></p>\r\n\r\n<p>Slow down there, cowboy. Let&apos;s try adding a conditional block.</p>\r\n\r\n<pre class=&quot;language-html&quot;><code>{{ if true }}hello {{test}}{{ endif }}</code></pre>\r\n\r\n<p>I&apos;ll save you the gory details, but the regex for this ended up looking something like this: <code>/{{\\s*?if\\s*?([\\s\\S]*?)\\s*?}}([\\s\\S]*){{\\s*?endif\\s*?}}/i</code>.</p>\r\n\r\n<p>Next I added support for array and object loops, with a method that I would be proud of if this entire approach hadn&apos;t been doomed from the start. I even got it to support partial includes before got to the only part which really matters...</p>\r\n\r\n<h1>The Eagle&apos;s Nest</h1>\r\n\r\n<p>Somehow I had managed to get really far with this regex approach before I even started thinking about how it would work when you start nesting conditional and loop blocks. When I finally started trying it out, I realized that my regex capturing group couldn&apos;t always be greedy or always be lazy. Consider the following simple examples:</p>\r\n\r\n<pre class=&quot;language-html&quot;><code>{{if true}}\r\n    foo\r\n{{endif}}\r\n{{if false}}\r\n    bar\r\n{{endif}}\r\n</code></pre>\r\n\r\n<p>If my capturing group is greedy, then it will match everything between <code>{{if true}}</code> and the second <code>{{endif}}</code>. That gives us unbalanced tags which will break everything.</p>\r\n\r\n<pre class=&quot;language-html&quot;><code>{{if true}}\r\n    foo\r\n    {{if false}}\r\n        bar\r\n    {{endif}}\r\n{{endif}}\r\n</code></pre>\r\n\r\n<p>Here we have a nested block. If our capturing group is lazy, then it will capture everything between <code>{{if true}}</code> and the first <code>{{endif}}</code>, which is also wrong. So we can&apos;t always be greedy, and we can&apos;t always be lazy. Funny how coding teaches you about life.</p>\r\n\r\n<p>I should have taken a step back right here. I was looking a the tip of the iceberg in terms of complexity. I could sense that what I really needed was a recursive capturing group, but JavaScript regex doesn&apos;t support that, so I kept my head down and plowed on.</p>\r\n\r\n<p>Stubbornly, I added logic to use greedy matching when blocks are nested and lazy matching when they aren&apos;t. That covers the vast majority of use cases, so I went on to start working on performance, filters, html escaping, and even made a site or two using the template engine with no problems.</p>\r\n\r\n<p>It wasn&apos;t until I started enhancing the unit tests that I realized my logic wasn&apos;t finished. When blocks were nested beyond one level, there were cases where my regex was still wrong. This had me stumped for a while. I had spent so much time using this approach that I couldn&apos;t see the real problem - if I couldn&apos;t use a recursive capturing group, I couldn&apos;t support recursive (nested) tags.</p>\r\n\r\n<p>Yet again, I plowed onward. This time I wrote a recursive function that would check the contents of a template for nested tags and build a regex dynamically to match that specific content, then apply that regex to the content it had parsed. Oh how far I had strayed from the elegant, simple implementation I set out to create. At least it finally worked.</p>\r\n\r\n<p>Technically, anyway. But there was another problem. You see, something had been bothering me for a while. All the other template engines I looked at had this thing called a &quot;compile&quot; step. I wasn&apos;t sure exactly what that was. Upon further investigation, I noticed that these compile functions would return a function that could be called using a context object, without even specifying a template. So they were somehow turning a template into a reusable function, thus limiting file I/O to one read per template per process. </p>\r\n\r\n<p>The fact that I didn&apos;t quite understand this makes it no surprise that, when benchmarked, my template engine was orders of magnitude slower than the others. I was reading the file and recursively constructing dynamic regular expressions on every render. To make matters worse, I was relying on node&apos;s <code>vm.runInNewContext</code> method, which is well known as a performance nightmare. The idea behind this feature is great - it&apos;s basically <code>eval</code> but with its own fresh scope that you can define. Unfortunately, the construction of this new context is horrible in terms of performance, especially when called repeatedly in a short timespan. </p>\r\n\r\n<p>This is where my refusal to question my approach for months on end really bit me. I had ignored the performance problem in favor of the nesting problem, devoted hours and hours of my evenings (my poor girlfriend), finally solved the issue with an incredibly complex and ugly implementation, and now I had a template engine that technically worked but was unacceptably slow. </p>\r\n\r\n<h1>The Rewrite</h1>\r\n\r\n<p>I tried replacing <code>vm.runInNewContext</code> with native JavaScript&apos;s <code>with</code> statement to see the performance impact. It was huge, to be clear, but it wasn&apos;t enough. And, what&apos;s more, I had come to hate the code I was working on. I threw my hands up and deleted it.</p>\r\n\r\n<p>After looking at the source code of some other template engines, one stuck out to me as being pretty darn close to the kind of simplicity I was shooting for. That was John Resig&apos;s <a href=&quot;http://ejohn.org/blog/javascript-micro-templating/&quot; target=&quot;_blank&quot;>micro templates</a>. It was an entirely different approach - rather than trying to recursively match tags containing certain key words, simply split the template up at the tags, treat the markup as a string, and run the whole thing as a function (the idea behind &quot;compiling a template&quot; was finally clicking). </p>","date":"Thu Feb 18 2016","live":"on"}}