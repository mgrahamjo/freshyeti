{"writing-a-template-engine":{"title":"Writing a template engine is hard","body":"<p>When I set out to write the <a href=&quot;/breadbox&quot;>Breadbox</a> framework, the thing I was most excited about was writing my own template engine. Now, six months later, I can&apos;t express just how naive that excitement was. Not only did I not know what I was doing, but I had a grave misunderstanding of the limitations of regex in JavaScript which would send me down a path that ultimately let do me <code>rm -rf</code>ing 5 months of work (that&apos;s deleting for any non bashers out there).</p>\r\n\r\n<p>There&apos;s one thing I was right about. The template engines available for Node today kind of suck. Pretty much all of them have weird arbitrary syntax requirements. Some of the most developer-friendly ones are also the slowest. And some are okay for developers but totally alien for designers. I haven&apos;t solved that last one yet, but at this point I&apos;ll settle for 2 out of 3 goals.</p>\r\n\r\n<h3>The blank slate</h3>\r\n\r\nIn the beginning, it was fun. It started with this:\r\n\r\n<pre class=&quot;language-html&quot;><code>hello {{test}}</code</pre>\r\n\r\nThen, with a simple regex, I wrote a function that would get the template and spit out this:\r\n\r\n<pre class=&quot;language-html&quot;><code>hello world</code</pre>\r\n\r\n<p><em>&quot;Woohoo! I&apos;m a genious! I can&apos;t believe people make this sound so hard!</em></p>\r\n\r\n<p>Slow down there, cowboy. Let&apos;s try adding a conditional block.</p>\r\n\r\n<pre class=&quot;language-html&quot;><code>{{ if true }}hello {{test}}{{ endif }}</code</pre>\r\n\r\n<p>I&apos;ll save you the gory details, but the regex for this ended up looking something like this: <code>/{{\\s*?if\\s*?([\\s\\S]*?)\\s*?}}([\\s\\S]*){{\\s*?endif\\s*?}}/i</code>.</p>\r\n\r\n<p>Next I added support for array and object loops, with a method that I would be proud of if this entire approach hadn&apos;t been doomed from the start. I even got it to support partial includes before got to the only part which really matters...</p>\r\n\r\n<h3>The Eagle&apos;s Nest</3>\r\n\r\n<p>Somehow I had managed to get really far with this regex approach before I even started thinking about how it would work when you start nesting conditional and loop blocks. When I finally started trying it out, I realized that my regex capturing group couldn&apos;t always be greedy or always be lazy. Consider the following simple examples:</p>\r\n\r\n<pre class=&quot;language-html&quot;><code>{{if true}}\r\n    foo\r\n{{endif}}\r\n{{if false}}\r\n    bar\r\n{{endif}}\r\n</code></pre>\r\n\r\n<p>If my capturing group is greedy, then it will match everything between <code>{{if true}}</code> and the second <code>{{endif}}<code>. That gives us unbalanced tags which will break everything.</p>\r\n\r\n<pre class=&quot;language-html&quot;><code>{{if true}}\r\n    foo\r\n    {{if false}}\r\n        bar\r\n    {{endif}}\r\n{{endif}}\r\n</code></pre>\r\n\r\n<p>Here we have a nested block. If our capturing group is lazy, then it will capture everything between <code>{{if true}}</code> and the first <code>{{endif}}</code>, which is also wrong. So we can&apos;t always be greedy, and we can&apos;t always be lazy. Funny how coding teaches you about life.</p>\r\n\r\n<p>I should have taken a step back right here. I was looking a the tip of the iceberg in terms of complexity. I could sense that what I really needed was a recursive capturing group, but JavaScript regex doesn&apos;t support that, so I kept my head down and plowed on.</p>\r\n\r\n<p>Embarrassingly, I added logic to use greedy matching when blocks are nested and lazy matching when they aren&apos;t. That covers the vast majority of use cases, so I went on to start working on performance, filters, html escaping, and even made a site or two using the template engine with no problems.</p>\r\n\r\n<p>It wasn&apos;t until I started enhancing the unit tests that I realized my logic wasn&apos;t finished. When blocks were nested beyond one level, there were cases where my regex was still wrong. This had me stumped for a while. I had spent so much time using this approach that I couldn&apos;t see the real problem - if I couldn&apos;t use a recursive capturing group, I couldn&apos;t support recursive (nested) tags.</p>\r\n\r\n<p>Yet again, I plowed onward. This time I wrote a recursive function that would check the contents of a template for nested tags and build a regex dynamically to match that specific content, then apply that regex to the content it had parsed. Oh how far I had strayed from the elegant, simple implementation I set out to create. At least, finally it worked.</p>\r\n\r\n<p>Technically, anyway. But there was another problem. You see, something had been bothering me for a while. All the other template engines I looked at had this thing called a &quot;compile&quot; step. I wasn&apos;t sure exactly what that was. Upon further investigation, I noticed that these compile functions would return a function that could be called using a context object, without even telling them which template to use. So they were somehow turning a template into a reusable function, thus limiting file I/O to one read per template. </p>\r\n\r\n<p>The fact that I didn&apos;t quite understand this makes it no surprise that, when benchmarked, my template engine was orders of magnitude slower than the others. I was reading the file and recursively constructing dynamic regular expressions on every render. If it were just that, I might have been okay, though - the real dog was the use of node&apos;s <code>vm.runInNewContext</code> method. The idea behind this feature is great - it&apos;s basically <code>eval</code> but with its own fresh scope that you can define. Unfortunately, the construction of this new context is horrible in terms of performance, especially when called repeatedly in a short timespan. </p>\r\n\r\n<p>This is where my refusal to question my approach for months on end really bit me. I had ignored the performance problem in favor of the nesting problem, devoted hours and hours of my evenings to my poor girlfriend&apos;s chagrin, finally solved the issue with an incredibly complex and ugly implementation, and now I had a template engine that technically worked but was unacceptably slow. ","date":"Thu Feb 18 2016"}}