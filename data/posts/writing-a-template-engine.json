{"writing-a-template-engine":{"title":"Writing a template engine is hard","body":"<p>When I set out to write the <a href=\"/breadbox\">Breadbox</a> framework, the thing I was most excited about was writing my own template engine. Now, six months later, I can't express just how naive that excitement was. Not only did I not know what I was doing, but I had a grave misunderstanding of the limitations of regex in JavaScript which would send me down a path that ultimately let to me <code>rm -rf</code>ing 5 months of work (that's deleting for any non bashers out there).</p>\r\n\r\n<p>There's one thing I was right about. The template engines available for Node today kind of suck. Pretty much all of them have weird arbitrary syntax requirements. Some of the most developer-friendly ones are also the slowest. And some are okay for developers but totally alien for designers. I haven't solved that last one yet, but at this point I'll settle for 2 out of 3 goals.</p>\r\n\r\n<h1>The blank slate</h1>\r\n\r\n<p>In the beginning, it was fun. It started with this:</p>\r\n\r\n<pre class=\"language-html\"><code>hello {{test}}</code></pre>\r\n\r\n<p>Then, with a simple regex, I wrote a function that would get the template and spit out this:</p>\r\n\r\n<pre class=\"language-html\"><code>hello world</code></pre>\r\n\r\n<p><em>\"Woohoo! I'm a genious! I can't believe people make this sound so hard!</em></p>\r\n\r\n<p>Slow down there, cowboy. Let's try adding a conditional block.</p>\r\n\r\n<pre class=\"language-html\"><code>{{ if true }}hello {{test}}{{ endif }}</code></pre>\r\n\r\n<p>I'll save you the gory details, but the regex for this ended up looking something like this: <code>/{{\\s*?if\\s*?([\\s\\S]*?)\\s*?}}([\\s\\S]*){{\\s*?endif\\s*?}}/i</code>.</p>\r\n\r\n<p>Next I added support for array and object loops, with a method that I would be proud of if this entire approach hadn't been doomed from the start. I even got it to support partial includes before got to the only part which really matters...</p>\r\n\r\n<h1>The Eagle's Nest</h1>\r\n\r\n<p>Somehow I had managed to get really far with this regex approach before I even started thinking about how it would work when you start nesting conditional and loop blocks. When I finally started trying it out, I realized that my regex capturing group couldn't always be greedy or always be lazy. Consider the following simple examples:</p>\r\n\r\n<pre class=\"language-html\"><code>{{if true}}\r\n    foo\r\n{{endif}}\r\n{{if false}}\r\n    bar\r\n{{endif}}\r\n</code></pre>\r\n\r\n<p>If my capturing group is greedy, then it will match everything between <code>{{if true}}</code> and the second <code>{{endif}}</code>. That gives us unbalanced tags which will break everything.</p>\r\n\r\n<pre class=\"language-html\"><code>{{if true}}\r\n    foo\r\n    {{if false}}\r\n        bar\r\n    {{endif}}\r\n{{endif}}\r\n</code></pre>\r\n\r\n<p>Here we have a nested block. If our capturing group is lazy, then it will capture everything between <code>{{if true}}</code> and the first <code>{{endif}}</code>, which is also wrong. So we can't always be greedy, and we can't always be lazy. Funny how coding teaches you about life.</p>\r\n\r\n<p>I should have taken a step back right here. I was looking a the tip of the iceberg in terms of complexity. I could sense that what I really needed was a recursive capturing group, but JavaScript regex doesn't support that, so I kept my head down and plowed on.</p>\r\n\r\n<p>Stubbornly, I added logic to use greedy matching when blocks are nested and lazy matching when they aren't. That covers the vast majority of use cases, so I went on to start working on performance, filters, html escaping, and even made a site or two using the template engine with no problems.</p>\r\n\r\n<p>It wasn't until I started enhancing the unit tests that I realized my logic wasn't finished. When blocks were nested beyond one level, there were cases where my regex was still wrong. This had me stumped for a while. I had spent so much time using this approach that I couldn't see the real problem - if I couldn't use a recursive capturing group, I couldn't support recursive (nested) tags.</p>\r\n\r\n<p>Yet again, I plowed onward. This time I wrote a recursive function that would check the contents of a template for nested tags and build a regex dynamically to match that specific content, then apply that regex to the content it had parsed. Oh how far I had strayed from the elegant, simple implementation I set out to create. At least it finally worked.</p>\r\n\r\n<p>Technically, anyway. But there was another problem. You see, something had been bothering me for a while. All the other template engines I looked at had this thing called a \"compile\" step. I wasn't sure exactly what that was. Upon further investigation, I noticed that these compile functions would return a function that could be called using a context object, without even specifying a template. So they were somehow turning a template into a reusable function, thus limiting file I/O to one read per template per process. </p>\r\n\r\n<p>The fact that I didn't quite understand this makes it no surprise that, when benchmarked, my template engine was orders of magnitude slower than the others. I was reading the file and recursively constructing dynamic regular expressions on every render. To make matters worse, I was relying on node's <code>vm.runInNewContext</code> method, which is well known as a performance nightmare. The idea behind this feature is great - it's basically <code>eval</code> but with its own fresh scope that you can define. Unfortunately, the construction of this new context is horrible in terms of performance, especially when called repeatedly in a short timespan. </p>\r\n\r\n<p>This is where my refusal to question my approach for months on end really bit me. I had ignored the performance problem in favor of the nesting problem, devoted hours and hours of my evenings (my poor girlfriend), finally solved the issue with an incredibly complex and ugly implementation, and now I had a template engine that technically worked but was unacceptably slow. </p>\r\n\r\n<h1>The Rewrite</h1>\r\n\r\n<p>I tried replacing <code>vm.runInNewContext</code> with native JavaScript's <code>with</code> statement to see the performance impact. It was huge, to be clear, but it wasn't enough. And, what's more, I had come to hate the code I was working on. I threw my hands up and deleted it.</p>\r\n\r\n<p>After looking at the source code of some other template engines, one stuck out to me as being pretty darn close to the kind of simplicity I was shooting for. That was John Resig's <a href=\"http://ejohn.org/blog/javascript-micro-templating/\" target=\"_blank\">micro templates</a>. It was an entirely different approach - rather than trying to recursively match tags containing certain key words, simply split the template up at the tags, treat the markup as a string, and run the whole thing as a function (the idea behind \"compiling a template\" was finally clicking). </p>\r\n\r\n<p>There were a few issues, though.</p>\r\n<ul>\r\n<li>His template engine removes all newlines.</li>\r\n<li>Single quotes can break the compiled function.</li>\r\n<li>Any reference to an undefined variable in a template prints \"undefined\".</li>\r\n<li>He uses three instances of  <code>replace</code> and four of <code>.split().join()</code>. Regex replaces are faster (at least in Node) and easier to read in my opinion.</li>\r\n<li>He doesn't HTML escape content.</li>\r\n</ul>\r\n\r\n<p>The fix for stripping newlines was easy - I just don't do it. John's regexes rely on the fact that matches can't span newlines or tabs. By simplifying the regexes I was able to avoid that and leave newlines intact. </p>\r\n\r\n<p>The issue with single quotes would be a deal breaker. After floundering for a bit, I realized I have an option available to me that John didn't when he wrote this. I can use ES2015 template strings within my compiled function, which means you can use single and double quotes to your heart's content throughout the template. This does mean you can't use ES2015 template strings within your template expressions, but I'm not sure I even want to support template strings within template tags within templates.</p> \r\n\r\n<p>Next, in the case that an undefined variable is referenced in a template, I wanted to print nothing, rather than printing <code>undefined</code> or throwing an error. This is contrary to the behavior of JavaScript, but the fix was easy, and actually boosts performance. When I match a template tag with something like <code>/<<(.*?)>>/g</code>, rather than replacing it directly with its evaluated result, I replace it with <code>(typeof $1 === 'undefined' ? ' : _e_($1))</code>, where <code>_e_</code> is an HTML escaping function. </p>\r\n\r\n<p>I didn't like the use of <code>string.split().join()</code> to do substitution. I rewrote the logic and the regexes to suit my preferences and performance goals, and wound up with a function that performs 40% fewer string transforms with more functionality, including separate regexes to do matches without HTML escaping.</p>\r\n\r\n<p>I also kept the same logic for partial includes from my previous attempt, as Resig's micro templates were intended for the front end and don't support includes. </p>\r\n\r\n<h1>Fin</h1>\r\n\r\n<p>In the end, I'm glad I pulled off what I did. I didn't get the mystically elegant and sleek product that I hoped for. In fact, I failed to meet one of my goals, which was to build a more intuitive syntax (I ended up using JavaScript as my templating language). But, after learning the enormity of the task I set out to accomplish on the odd weekday evening, I'm happy to have put out something functional, more performant than some of the successful competition, and easy to use. Check out <a href=\"https://github.com/mgrahamjo/manila\" target=\"_blank\">manila on github</a>, and open an issue if you have any requests.</p>","date":"Thu Feb 18 2016","live":"on"}}