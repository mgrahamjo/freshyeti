{"watching-file-changes-npm-scripts":{"title":"Watching file changes with NPM Scripts","body":"<p>A year or two ago, front end developers had this sudden realization: task runners like Grunt and Gulp are just wrappers for existing CLIs, and using those CLIs directly is actually easier than trying to configure a task runner. Since then, the trend is to call your build tasks using npm scripts defined in your package.json.</p>\r\n\r\n<p>I love removing dependencies from my project, so I was sold on building with npm scripts right away. I was a tad disappointed, though, when I saw that there isn't built-in support for watching files for changes. If you're lucky enough to be using only dependencies that have their own watch support, that's great, but otherwise you'll need to come up with a file watching solution. I've tried <a href=\"https://www.npmjs.com/package/npm-watch\" target=\"_blank\">npm-watch</a>, <a href=\"https://www.npmjs.com/package/watch\" target=\"_blank\">watch</a>, and <a href=\"https://www.npmjs.com/package/nodemon\" target=\"_blank\">nodemon</a>. npm-watch has the best interface, but uses nodemon under the hood, which is crazy heavy and not built for this purpose. Watch is okay but requires an additional plugin like npm-run-all to parallelize multiple watchers (i.e. for separate JS and CSS build processes).</p>\r\n\r\n<p>So I felt like there's unnecessary complexity around this file watching problem, and decided to see if I could just solve the problem myself using node's built-in <code>fs.watch</code> method. Turns out it's crazy easy, and took about 10 minutes to switch from npm-watch to a custom watcher.</p>\r\n\r\n<h3>package.json</h3>\r\n<pre class=\"language-javascript\"><code>\r\n...\r\n\"scripts\": {\r\n  \"build\": \"./bin/build.sh\",\r\n  \"scss\": \"./bin/css/stylelint.sh; ./bin/css/sass.sh; ./bin/css/autoprefix.sh\",\r\n  \"js\": \"node bin/js/fusebox.js\",\r\n  \"watch\": \"node bin/watch.js\"\r\n},\r\n...\r\n</code></pre>\r\n\r\n<p>So I have a few npm scripts - one to build the whole project for deployment, one that lints and builds scss files, and one that just bundles my JavaScript files. Then there's the one that watches files for changes. Here's what that script looks like:</p>\r\n\r\n<h3>bin/watch.js</h3>\r\n<pre class=\"language-javascript\"><code>\r\nconst fs = require('fs'),\r\n    spawn = require('child_process').spawn;\r\n\r\nfs.watch('src', {\r\n    recursive: true // watch everything in the directory\r\n}, (e, file) => {\r\n    // Use the extension of the file as the npm script name\r\n    const script = file.split('.').pop();\r\n\r\n    if (['js', 'scss'].includes(script)) {\r\n        // Spawn the process\r\n        const p = spawn('npm', ['run', script], {\r\n            stdio: 'inherit' // pipe output to the console\r\n        });\r\n        // Print something when the process completes\r\n        p.on('close', code => {\r\n            if (code === 1) {\r\n                console.error(`âœ– \"npm run ${script}\" failed.`);\r\n            } else {\r\n                console.log('watching for changes...');\r\n            }\r\n        });\r\n    }\r\n});\r\n\r\nconsole.log('watching for changes...');\r\n</code></pre>\r\n\r\n<p>And that's it. Now I can run <code>npm run watch</code>, and then my css build runs when I change an scss file, and my js build runs when I change a JavaScript file. Admittedly, my implementation is a little tricky because it uses the extension of the changed file as the npm script name, but you could certainly use a switch statement to call other scripts based on what files were changed.</p>","date":"Wed Dec 28 2016","live":"on"}}