{"callbacks-promises-and-bears-oh-my":{"title":"Support both callbacks and promises in your Node modules","body":"<p>One of <a href=&quot;https://blog.risingstack.com/how-to-become-a-better-node-js-developer-in-2016/&quot;>Rising Stack&#39;s</a> top suggestions for being a good Node dev in 2016 is to export modules that support both callbacks and promises.</p>\r\n<p>For example, when I made the <a href=&quot;https://www.npmjs.com/package/manila&quot;>manila template engine</a>, I naturally wanted to support Express, which expects to be able to pass in a callback. At the same time, when using manila with vanilla node (nice rhyme) it would be nice to use promises instead.</p>\r\n<p>However, Rising Stack&#39;s suggested approach felt just a bit icky to me. I don&#39;t like the idea of always having to call both the callback and resolve(), knowing that one of the calls isn&#39;t doing anything.</p>\r\n<p>Here&#39;s the approach I&#39;m currently using. It&#39;ll be nicer once Node supports destructuring.</p>\r\n<pre><code>function promisify(callback, resolve, reject) {\r\n    resolve = callback ? data =&gt; {\r\n        callback(undefined, data);\r\n    } : resolve;\r\n    reject = callback ? error =&gt; {\r\n        callback(error);\r\n    } : reject;\r\n    return {\r\n        resolve: resolve,\r\n        reject: reject\r\n    };\r\n}\r\n\r\nmodule.exports = callback =&gt; {\r\n    return new Promise((resolve, reject) =&gt; {\r\n        let p = promisify(callback, resolve, reject);\r\n        doSomethingAsync().then(result =&gt; {\r\n            p.resolve(result);\r\n        }).catch(error =&gt; {\r\n            p.reject(error);\r\n        });\r\n    });\r\n}\r\n</code></pre>","date":"Fri Jan 29 2016","live":"on"}}