{"persistent-in-memory-sessions":{"title":"Persistent in-memory sessions for NodeJS","body":"<p>When I set out to write authentication for <a href=\"/breadbox\">Breadbox</a>, I had to decide if I wanted sessions to be stored in a database or in memory. The database option is the de facto standard, for a few reasons:</p>\r\n<ul>\r\n<li>It's more scalable</li>\r\n<li>It's more portable (session info can easily be shared between app servers)</li>\r\n<li>It's persistent (if you restart your server the sessions are still there)</li>\r\n</ul>\r\n<p>But I found myself stuck on the obvious downside: you have to make an extra database call on every single request. For the purposes of a simple blog server that would realistically only ever have one user logged in at a time, I hated the idea of hitting a database just to see if the request is authenticated. At the same time, the thought of losing all current session info any time I restart the server wasn't acceptable. After furrowing my brow for a while at the apparent wall-and-a-hard-place situation, I realized that there is a little feature of Node that would allow me to create in-memory sessions that would survive a server restart - on purpose or due to a crash.</p>\r\n<p>By hooking in to <code>process.on('uncaughtException')</code> and <code>process.on('SIGINT')</code>, I get a chance to do dump the session data to a JSON file before the server actually shuts down. Then, when the server starts up, I read the JSON dump into the session object and delete the file. It looks like this:</p>\r\n<pre><code class=\"language-javascript\">// Before crashing, save current sessions.\r\nprocess.on('uncaughtException', err => {\r\n  fs.writeFile('session-dump.json', JSON.stringify(session.all()), () => {\r\n    console.error(err.stack);\r\n    process.exit(1);\r\n  });\r\n});\r\n\r\n// Before interrupting the server manually, save current sessions.\r\nprocess.on('SIGINT', () => {\r\n  db.put('session-dump', session.all()).then(() => {\r\n    process.exit();\r\n  });\r\n});\r\n\r\n// On start up, recover session data, if any.\r\ndb.get('session-dump').then(data => {\r\n  session.set(data);\r\n  db.del('session-dump');\r\n});\r\n</code></pre><p>You might notice that in the case of an uncaught exception I'm bypassing my module for file-based storage and using <code>fs.writeFile</code> directly. If the app is crashing, then we need to shut down ASAP without mucking around. It could very well be the <code>db</code> module that threw the exception, so trying to use it in the exception handler could spark a nasty loop.</p>\r\n<p><code>session</code>, as you can see, has a few methods for interacting with session data. I attach it to the <code>request</code> object that gets passed to controllers, as well as a shorthand <code>request.sess</code> which provides quick access to the session associated with the current request without having to check the cookie.</p>\r\n<p>The API for <code>session</code> can be found within the <a href=\"/breadbox#session\">Breadbox docs</a>.</p>\r\n<p><strong>Update Oct 20th 2016:</strong></p>\r\n<p>A year later it's clear that <a href=\"https://jwt.io/introduction/\">JSON Web Tokens</a> should have been in the running for my authentication solution. If I were to start over, there's a good chance I would go that direction, but the solution described above still has the advantage of smaller request payloads.</p>","date":"Thu Oct 29 2015","live":"on"}}