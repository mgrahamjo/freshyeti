{"persistent-in-memory-sessions":{"title":"Persistent in-memory sessions for NodeJS","body":"&lt;p&gt;When I set out to write authentication for &lt;a href=&quot;/breadbox&quot;&gt;Breadbox&lt;/a&gt;, I had to decide if I wanted sessions to be stored in a database or in memory. The database option is the de facto standard, for a few reasons:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;It&amp;#39;s more scalable&lt;/li&gt;\r\n&lt;li&gt;It&amp;#39;s more portable (session info can easily be shared between app servers)&lt;/li&gt;\r\n&lt;li&gt;It&amp;#39;s persistent (if you restart your server the sessions are still there)&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;But I found myself stuck on the obvious downside: you have to make an extra database call on every single request. For the purposes of a simple blog server that would realistically only ever have one user logged in at a time, I hated the idea of hitting a database just to see if the request is authenticated. At the same time, the thought of losing all current session info any time I restart the server wasn&amp;#39;t acceptable. After furrowing my brow for a while at the apparent wall-and-a-hard-place situation, I realized that there is a little feature of Node that would allow me to create in-memory sessions that would survive a server restart - on purpose or due to a crash.&lt;/p&gt;\r\n&lt;p&gt;By hooking in to &lt;code&gt;process.on(&amp;#39;uncaughtException&amp;#39;)&lt;/code&gt; and &lt;code&gt;process.on(&amp;#39;SIGINT&amp;#39;)&lt;/code&gt;, I get a chance to do dump the session data to a JSON file before the server actually shuts down. Then, when the server starts up, I read the JSON dump into the session object and delete the file. It looks like this:&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;// Before crashing, save current sessions.\r\nprocess.on(&amp;#39;uncaughtException&amp;#39;, err =&amp;gt; {\r\n  fs.writeFile(&amp;#39;session-dump.json&amp;#39;, JSON.stringify(session.all()), () =&amp;gt; {\r\n    console.error(err.stack);\r\n    process.exit(1);\r\n  });\r\n});\r\n\r\n// Before interrupting the server manually, save current sessions.\r\nprocess.on(&amp;#39;SIGINT&amp;#39;, () =&amp;gt; {\r\n  db.put(&amp;#39;session-dump&amp;#39;, session.all()).then(() =&amp;gt; {\r\n    process.exit();\r\n  });\r\n});\r\n\r\n// On start up, recover session data, if any.\r\ndb.get(&amp;#39;session-dump&amp;#39;).then(data =&amp;gt; {\r\n  session.set(data);\r\n  db.drop(&amp;#39;session-dump&amp;#39;);\r\n});\r\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You might notice that in the case of an uncaught exception I&amp;#39;m bypassing my module for file-based storage and using &lt;code&gt;fs.writeFile&lt;/code&gt; directly. If the app is crashing, then we need to shut down ASAP without mucking around. It could very well be the &lt;code&gt;db&lt;/code&gt; module that threw the exception, so trying to use it in the exception handler could spark a nasty loop.&lt;/p&gt;\r\n&lt;p&gt;&lt;code&gt;session&lt;/code&gt;, as you can see, has a few methods for interacting with session data. I attach it to the &lt;code&gt;request&lt;/code&gt; object that gets passed to controllers, as well as a shorthand &lt;code&gt;request.sess&lt;/code&gt; which provides quick access to the session associated with the current request without having to check the cookie. &lt;/p&gt;\r\n&lt;p&gt;The API for &lt;code&gt;session&lt;/code&gt; can be found within the &lt;a href=&quot;/breadbox#session&quot;&gt;Breadbox docs&lt;/a&gt;.&lt;/p&gt;\r\n","date":"Thu Oct 29 2015"}}