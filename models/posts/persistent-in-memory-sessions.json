{"persistent-in-memory-sessions":{"title":"Persistent in-memory sessions for NodeJS","body":"<p>When I set out to write authentication for <a href=&quot;/breadbox&quot;>Breadbox</a>, I had to decide if I wanted sessions to be stored in a database or in memory. The database option is the de facto standard, for a few reasons:</p>\r\n<ul>\r\n<li>It&apos;s more scalable</li>\r\n<li>It&apos;s more portable (session info can easily be shared between app servers)</li>\r\n<li>It&apos;s persistent (if you restart your server the sessions are still there)</li>\r\n</ul>\r\n<p>But I found myself stuck on the obvious downside: you have to make an extra database call on every single request. For the purposes of a simple blog server that would realistically only ever have one user logged in at a time, I hated the idea of hitting a database just to see if the request is authenticated. At the same time, the thought of losing all current session info any time I restart the server wasn&apos;t acceptable. After furrowing my brow for a while at the apparent wall-and-a-hard-place situation, I realized that there is a little feature of Node that would allow me to create in-memory sessions that would survive a server restart - on purpose or due to a crash.</p>\r\n<p>By hooking in to <code>process.on(&apos;uncaughtException&apos;)</code> and <code>process.on(&apos;SIGINT&apos;)</code>, I get a chance to do dump the session data to a JSON file before the server actually shuts down. Then, when the server starts up, I read the JSON dump into the session object and delete the file. It looks like this:</p>\r\n<pre><code>// Before crashing, save current sessions.\r\nprocess.on(&apos;uncaughtException&apos;, err =&amp;gt; {\r\n  fs.writeFile(&apos;session-dump.json&apos;, JSON.stringify(session.all()), () =&amp;gt; {\r\n    console.error(err.stack);\r\n    process.exit(1);\r\n  });\r\n});\r\n\r\n// Before interrupting the server manually, save current sessions.\r\nprocess.on(&apos;SIGINT&apos;, () =&amp;gt; {\r\n  db.put(&apos;session-dump&apos;, session.all()).then(() =&amp;gt; {\r\n    process.exit();\r\n  });\r\n});\r\n\r\n// On start up, recover session data, if any.\r\ndb.get(&apos;session-dump&apos;).then(data =&amp;gt; {\r\n  session.set(data);\r\n  db.drop(&apos;session-dump&apos;);\r\n});\r\n</code></pre><p>You might notice that in the case of an uncaught exception I&apos;m bypassing my module for file-based storage and using <code>fs.writeFile</code> directly. If the app is crashing, then we need to shut down ASAP without mucking around. It could very well be the <code>db</code> module that threw the exception, so trying to use it in the exception handler could spark a nasty loop.</p>\r\n<p><code>session</code>, as you can see, has a few methods for interacting with session data. I attach it to the <code>request</code> object that gets passed to controllers, as well as a shorthand <code>request.sess</code> which provides quick access to the session associated with the current request without having to check the cookie. </p>\r\n<p>The API for <code>session</code> can be found within the <a href=&quot;/breadbox#session&quot;>Breadbox docs</a>.</p>\r\n","date":"Thu Oct 29 2015"}}