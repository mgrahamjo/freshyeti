{"automating-the-command-line":{"title":"Automating the Command Line","body":"&lt;p&gt;Designers are often put in a tough spot. They&amp;#39;re expected to own HTML and CSS, which means they have to have a development environment. But that entails stuff like running a server, a CSS preprocessor, autoprefixer, managing npm or bower dependencies, using version control, etc. For simple projects, lucky folks can get away with something like CodeKit and a git GUI, but in most cases there will be a need to use the terminal somewhere along the line.&lt;/p&gt;\r\n&lt;p&gt;In my experience, this is a problem. On a recent project, at some point every day a designer would report that after pulling latest the app was totally broken, showing only a blank page. Usually, someone had checked in a new bower dependency and a quick &lt;code&gt;bower install&lt;/code&gt; was the solution. I quickly realized that not only could we automate bower and npm installs, but we could automate nearly all of the command line tasks required in a normal development workflow.&lt;/p&gt;\r\n&lt;p&gt;Here&amp;#39;s how I set up a file that, when double-clicked, does the following:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;Mounts a directory from a development EC2 instance to the local machine via SSHFS&lt;/li&gt;\r\n&lt;li&gt;Opens up an iterm tab and runs a grunt watch task that does stuff like:&lt;ul&gt;\r\n&lt;li&gt;runs &lt;code&gt;bower install&lt;/code&gt; when bower.json changes&lt;/li&gt;\r\n&lt;li&gt;runs &lt;code&gt;npm install&lt;/code&gt; when package.json changes&lt;/li&gt;\r\n&lt;li&gt;restarts the server when appropriate files change&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;Opens up a second iterm tab, SSHes into the dev box, and goes to the working directory for git commands.&lt;/li&gt;\r\n&lt;li&gt;the usual compilation, linting, and unit testing stuff that grunt watch is used for&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;There are a handful of scripts involved, with launch.command being the one designers can click on to get to work. unmount.command can also be clicked to unmount the project and end the grunt process.&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;launch/&lt;ul&gt;\r\n&lt;li&gt;scripts/&lt;ul&gt;\r\n&lt;li&gt;git.expect&lt;/li&gt;\r\n&lt;li&gt;grunt-watch.expect&lt;/li&gt;\r\n&lt;li&gt;kill-grunt.expect&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;config.sh&lt;/li&gt;\r\n&lt;li&gt;launch.command&lt;/li&gt;\r\n&lt;li&gt;unmount.command&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;h3 id=&quot;config-sh&quot;&gt;config.sh&lt;/h3&gt;\r\n&lt;pre&gt;&lt;code&gt;&amp;lt;i&amp;gt;# your development server&amp;lt;/i&amp;gt;\r\nHOST=&amp;quot;dev.server.com&amp;quot;\r\n&amp;lt;i&amp;gt;# your user on the server&amp;lt;/i&amp;gt;\r\nUSER=&amp;quot;username&amp;quot;\r\n&amp;lt;i&amp;gt;# an empty local dir to mount the remote files in&amp;lt;/i&amp;gt;\r\nLOCAL=&amp;quot;mountpoint&amp;quot;\r\n&amp;lt;i&amp;gt;# path to the repo on the server&amp;lt;/i&amp;gt;\r\nREMOTE=&amp;quot;remote/working/directory&amp;quot;\r\n&amp;lt;i&amp;gt;# where to run grunt on the server&amp;lt;/i&amp;gt;\r\nGRUNTDIR=&amp;quot;path/to/grunt/dir&amp;quot;\r\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;launch-command&quot;&gt;launch.command&lt;/h3&gt;\r\n&lt;p&gt;This script does three main things:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;Mounts the remote working directory using &lt;a href=&quot;http://fuse.sourceforge.net/sshfs.html&quot;&gt;SSHFS&lt;/a&gt;&lt;/li&gt;\r\n&lt;li&gt;Tells iTerm to open a tab and run the grunt-watch.expect script&lt;/li&gt;\r\n&lt;li&gt;Tells iTerm to open another tab and run the git.expect script&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;pre&gt;&lt;code&gt;&amp;lt;i&amp;gt;#!/bin/bash&amp;lt;/i&amp;gt;\r\n&amp;lt;i&amp;gt;# reset $PWD&amp;lt;/i&amp;gt;\r\ncd `dirname $0`\r\nDIR=$PWD\r\n\r\n&amp;lt;i&amp;gt;# get config&amp;lt;/i&amp;gt;\r\n. $DIR/config.sh\r\n\r\n&amp;lt;i&amp;gt;# make sure the mount point exists&amp;lt;/i&amp;gt;\r\ncd ~ &amp;gt; /dev/null\r\nchmod -R +x $DIR &amp;gt; /dev/null 2&amp;gt;&amp;amp;1\r\nmkdir $LOCAL &amp;gt; /dev/null 2&amp;gt;&amp;amp;1\r\n\r\necho &amp;quot;mounting the remote filesystem...&amp;quot;\r\n\r\n&amp;lt;i&amp;gt;# mount the remote with some performance &amp;amp; usability options&amp;lt;/i&amp;gt;\r\nsshfs $USER@$HOST:$REMOTE $LOCAL -ovolname=$LOCAL,Ciphers=arcfour,reconnect,noappledouble,follow_symlinks\r\n\r\necho &amp;quot;opening iterm...&amp;quot;\r\n\r\n&amp;lt;i&amp;gt;# switch to osascript to talk to OSX&amp;lt;/i&amp;gt;\r\nosascript &amp;lt;&amp;lt;-eof\r\n  tell application &amp;quot;iTerm&amp;quot;\r\n    set _term to (make new terminal)\r\n    tell _term\r\n\r\n      &amp;lt;i&amp;gt;# open an item tab and run the grunt-watch script in it&amp;lt;/i&amp;gt;\r\n      launch session &amp;quot;Default session&amp;quot;\r\n      tell the last session\r\n        set name to &amp;quot;grunt&amp;quot;\r\n        write text &amp;quot;$DIR/scripts/grunt-watch.expect &amp;#39;$HOST&amp;#39; &amp;#39;$USER&amp;#39; &amp;#39;$GRUNTDIR&amp;#39; &amp;#39;$GRUNTCMD&amp;#39;&amp;quot;\r\n      end tell\r\n\r\n      &amp;lt;i&amp;gt;# open a second tab for git&amp;lt;/i&amp;gt;\r\n      launch session &amp;quot;git&amp;quot;\r\n      tell the last session\r\n        set name to &amp;quot;git&amp;quot;\r\n        write text &amp;quot;$DIR/scripts/git.expect &amp;#39;$HOST&amp;#39; &amp;#39;$USER&amp;#39; &amp;#39;$REMOTE&amp;#39;&amp;quot;\r\n      end tell\r\n    end tell\r\n  end tell\r\neof\r\nosascript -e &amp;#39;quit app &amp;quot;Terminal&amp;quot;&amp;#39; &amp;amp; exit 0\r\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;grunt-watch-expect&quot;&gt;grunt-watch.expect&lt;/h3&gt;\r\n&lt;p&gt;Expect is a pretty cool scripting language that can be used to interact with a terminal, sending different commands depending on what gets logged to stdout. This means you can handle situations like a first-time log in, in which the user is prompted to add the hostname to their list of known hosts. And before you ask, I wouldn&amp;#39;t try to automate logging in with a plaintext password. You could, but there&amp;#39;s no reason not to use RSA keys.&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;&amp;lt;i&amp;gt;#!/usr/bin/expect&amp;lt;/i&amp;gt;\r\n&amp;lt;i&amp;gt;# get config options&amp;lt;/i&amp;gt;\r\nset HOST [lindex $argv 0]\r\nset USER [lindex $argv 1]\r\nset GRUNTDIR [lindex $argv 2]\r\nset GRUNTCMD [lindex $argv 3]\r\n\r\n&amp;lt;i&amp;gt;# log in&amp;lt;/i&amp;gt;\r\nspawn ssh $USER@$HOST\r\nexpect &amp;quot;yes/no&amp;quot; { \r\n    send &amp;quot;yes\\r&amp;quot;\r\n} &amp;quot;$ &amp;quot; {\r\n    &amp;lt;i&amp;gt;# set session from expect to bash and run grunt&amp;lt;/i&amp;gt;\r\n        &amp;lt;i&amp;gt;# if your grunt task runs another process like a django or node server,&amp;lt;/i&amp;gt;\r\n        &amp;lt;i&amp;gt;# consider adding sudo killall python/node to prevent &amp;#39;port already in use&amp;#39;&amp;lt;/i&amp;gt;\r\n        &amp;lt;i&amp;gt;# when resuming after an interrupted session&amp;lt;/i&amp;gt;\r\n    send &amp;quot;sudo chsh -s /bin/bash; cd $GRUNTDIR; sudo killall grunt; $GRUNTCMD\\r&amp;quot;\r\n}\r\n&amp;lt;i&amp;gt;# hand control over to the user&amp;lt;/i&amp;gt;\r\ninteract\r\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;git-expect&quot;&gt;git.expect&lt;/h3&gt;\r\n&lt;p&gt;Similar deal here, but this time we&amp;#39;re just opening a tab in which to use git. You can try using git or a git GUI in the mounted directory on your local machine, but I&amp;#39;ve found that to be super slow, so I run git from the server.&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;&amp;lt;i&amp;gt;#!/usr/bin/expect&amp;lt;/i&amp;gt;\r\nset HOST [lindex $argv 0]\r\nset USER [lindex $argv 1]\r\nset REMOTE [lindex $argv 2]\r\nspawn ssh $USER@$HOST\r\nexpect &amp;quot;yes/no&amp;quot; {\r\n    send &amp;quot;yes\\r&amp;quot;\r\n} &amp;quot;$ &amp;quot; {\r\n    send &amp;quot;sudo chsh -s /bin/bash; cd $REMOTE; git status\\r&amp;quot;\r\n}\r\ninteract\r\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;unmount-command&quot;&gt;unmount.command&lt;/h3&gt;\r\n&lt;p&gt;This is the file you can double-click on to unmount the project and kill the grunt process that we started on the server.&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;&amp;lt;i&amp;gt;#!/bin/bash&amp;lt;/i&amp;gt;\r\n&amp;lt;i&amp;gt;# reset $PWD&amp;lt;/i&amp;gt;\r\ncd `dirname $0`\r\n&amp;lt;i&amp;gt;# source config options&amp;lt;/i&amp;gt;\r\n. $PWD/config.sh\r\n&amp;lt;i&amp;gt;# pass the options to the kill-grunt.expect script&amp;lt;/i&amp;gt;\r\n$PWD/scripts/kill-grunt.expect $HOST $USER\r\n&amp;lt;i&amp;gt;# unmount the project&amp;lt;/i&amp;gt;\r\ndiskutil unmount force ~/$LOCAL\r\nosascript -e &amp;#39;quit app &amp;quot;Terminal&amp;quot;&amp;#39; &amp;amp; exit 0\r\n&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;kill-grunt-expect&quot;&gt;kill-grunt.expect&lt;/h3&gt;\r\n&lt;p&gt;This one is called by unmount.command. It ends any grunt processes running on the server.&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;&amp;lt;i&amp;gt;#!/usr/bin/expect&amp;lt;/i&amp;gt;\r\nset HOST [lindex $argv 0]\r\nset USER [lindex $argv 1]\r\nspawn ssh $USER@$HOST\r\nexpect &amp;quot;$ &amp;quot; {\r\n    send &amp;quot;sudo killall grunt\\r&amp;quot;\r\n    expect &amp;quot;$ &amp;quot; { exit }\r\n}\r\n&lt;/code&gt;&lt;/pre&gt;","date":"Sat Oct 10 2015"}}