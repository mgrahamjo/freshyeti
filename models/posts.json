{"automating-the-command-line":{"title":"Automating the Command Line","body":"&lt;p&gt;Designers are often put in a tough spot. They&amp;#39;re expected to own HTML and CSS, which means they have to have a development environment. But that entails stuff like running a server, a CSS preprocessor, autoprefixer, managing npm or bower dependencies, using version control, etc. For simple projects, lucky folks can get away with something like CodeKit and a git GUI, but in most cases there will be a need to use the terminal somewhere along the line.&lt;/p&gt;\r\n&lt;p&gt;In my experience, this is a problem. On a recent project, every day a panicked designer would come to saying that after pulling latest the app was totally broken, showing only a blank page. Usually, someone had checked in a new bower dependency and a quick &lt;code&gt;bower install&lt;/code&gt; was the solution. I quickly realized that not only could we automate bower and npm installs, but we could automate nearly all of the command line tasks required in a normal development workflow.&lt;/p&gt;\r\n&lt;p&gt;Here&amp;#39;s how I set up a file that, when double-clicked, does the following:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;Mounts a directory from a development EC2 instance to the local machine via SSHFS&lt;/li&gt;\r\n&lt;li&gt;Opens up an iterm tab, SSHes into the dev box, and goes to the working directory for git commands.&lt;/li&gt;\r\n&lt;li&gt;Opens up a second iterm tab and runs a grunt watch task that does stuff like:&lt;/li&gt;\r\n&lt;li&gt;runs &lt;code&gt;bower install&lt;/code&gt; when bower.json changes&lt;/li&gt;\r\n&lt;li&gt;runs &lt;code&gt;npm install&lt;/code&gt; when package.json changes&lt;/li&gt;\r\n&lt;li&gt;restarts the server when appropriate files change&lt;/li&gt;\r\n&lt;li&gt;the usual compilation, linting, and unit testing stuff that grunt watch is used for&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;There are a handful of scripts involved, with launch.command being the one designers can click on to get to work. unmount.command can also be run to unmount the project and end the grunt process.&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;launch/&lt;ul&gt;\r\n&lt;li&gt;scripts/&lt;ul&gt;\r\n&lt;li&gt;git.expect&lt;/li&gt;\r\n&lt;li&gt;grunt-watch.expect&lt;/li&gt;\r\n&lt;li&gt;kill-grunt.expect&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;li&gt;config.sh&lt;/li&gt;\r\n&lt;li&gt;launch.command&lt;/li&gt;\r\n&lt;li&gt;unmount.command&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;p&gt;&lt;strong&gt;config.sh&lt;/strong&gt;&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;HOST=&amp;quot;dev.server.com&amp;quot; # your development server\r\nUSER=&amp;quot;username&amp;quot; # your user on the server\r\nLOCAL=&amp;quot;mountpoint&amp;quot; # an empty local dir to mount the remote files in\r\nREMOTE=&amp;quot;remote/working/directory&amp;quot; # path to the repo on the server\r\nGRUNTDIR=&amp;quot;path/to/grunt/dir&amp;quot;# where to run grunt on the server\r\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;launch.command&lt;/strong&gt;\r\nThis script does three main things:&lt;/p&gt;\r\n&lt;ul&gt;\r\n&lt;li&gt;Mounts the remote working directory using &lt;a href=&quot;http://fuse.sourceforge.net/sshfs.html&quot;&gt;SSHFS&lt;/a&gt;&lt;/li&gt;\r\n&lt;li&gt;Tells iTerm to open a tab and run the grunt-watch.expect script&lt;/li&gt;\r\n&lt;li&gt;Tells iTerm to open another tab and run the git.expect script&lt;/li&gt;\r\n&lt;/ul&gt;\r\n&lt;pre&gt;&lt;code&gt;#!/bin/bash\r\n# reset $PWD\r\ncd `dirname $0`\r\n# source config settings\r\n. $PWD/config.sh\r\n# make sure the mountpoint exists\r\ncd ~ &amp;gt; /dev/null\r\nchmod -R +x $PWD &amp;gt; /dev/null 2&amp;gt;&amp;amp;1\r\nmkdir $LOCAL &amp;gt; /dev/null 2&amp;gt;&amp;amp;1\r\necho &amp;quot;mounting the remote filesystem...&amp;quot;\r\nsshfs $USER@$HOST:$REMOTE $LOCAL &amp;gt; /dev/null\r\necho &amp;quot;opening iterm...&amp;quot;\r\n# switch to osascript to talk to iTerm\r\nosascript &amp;amp;lt;&amp;amp;lt;-eof\r\n tell application &amp;quot;iTerm&amp;quot;\r\n set _term to (make new terminal)\r\n  tell _term\r\n   launch session &amp;quot;Default session&amp;quot;\r\n   tell the last session\r\n   set name to &amp;quot;grunt&amp;quot;\r\n   # pass config options to grunt-watch.expect script\r\n   write text &amp;quot;~/$PWD/scripts/grunt-watch.expect &amp;#39;$HOST&amp;#39; &amp;#39;$USER&amp;#39; &amp;#39;$GRUNTDIR&amp;#39; &amp;#39;$GRUNTCMD&amp;#39;&amp;quot;\r\n  end tell\r\n  launch session &amp;quot;git&amp;quot;\r\n  tell the last session\r\n   set name to &amp;quot;git&amp;quot;\r\n   # pass config options to git.expect script\r\n   write text &amp;quot;~/$PWD/scripts/git.expect &amp;#39;$HOST&amp;#39; &amp;#39;$USER&amp;#39; &amp;#39;$REMOTE&amp;#39;&amp;quot;\r\n  end tell\r\n end tell\r\nend tell\r\neof\r\nosascript -e &amp;#39;quit app &amp;quot;Terminal&amp;quot;&amp;#39; &amp;amp; exit 0\r\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;grunt-watch.expect&lt;/strong&gt;\r\nExpect is a pretty cool scripting language that can be used to interact with a terminal, sending different commands depending on what gets logged to stdout. This means you can handle situations like a first-time log in, in which the user is prompted to add the hostname to their list of known hosts. And before you ask, I wouldn&amp;#39;t try to automate logging in with a plaintext password. You could, but there&amp;#39;s no reason not to use RSA keys.&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;#!/usr/bin/expect\r\n# get config options\r\nset HOST [lindex $argv 0]\r\nset USER [lindex $argv 1]\r\nset GRUNTDIR [lindex $argv 2]\r\nset GRUNTCMD [lindex $argv 3]\r\n# log in\r\nspawn ssh $USER@$HOST\r\nexpect &amp;quot;yes/no&amp;quot; { \r\n    send &amp;quot;yes\\r&amp;quot;\r\n} &amp;quot;$ &amp;quot; {\r\n# set session from expect to bash and run grunt\r\n    send &amp;quot;sudo chsh -s /bin/bash; cd $GRUNTDIR; $GRUNTCMD\\r&amp;quot;\r\n}\r\n# hand control over to the user\r\ninteract\r\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;git.expect&lt;/strong&gt;\r\nSimilar deal here, but this time we&amp;#39;re just opening a tab in which to use git. You can try using git or a git GUI in the mounted directory on your local machine, but I&amp;#39;ve found that to be super slow, so I run git from the server.&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;#!/usr/bin/expect\r\nset HOST [lindex $argv 0]\r\nset USER [lindex $argv 1]\r\nset REMOTE [lindex $argv 2]\r\nspawn ssh $USER@$HOST\r\nexpect &amp;quot;yes/no&amp;quot; {\r\n    send &amp;quot;yes\\r&amp;quot;\r\n} &amp;quot;$ &amp;quot; {\r\n    send &amp;quot;sudo chsh -s /bin/bash; cd $REMOTE; git status\\r&amp;quot;\r\n}\r\ninteract\r\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;unmount.command&lt;/strong&gt;\r\nThis is the file you can double-click on to unmount the project and kill the grunt process that we started on the server.&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;#!/bin/bash\r\n# reset $PWD\r\ncd `dirname $0`\r\n# source config options\r\n. $PWD/config.sh\r\n# pass the options to the kill-grunt.expect script\r\n$PWD/scripts/kill-grunt.expect $HOST $USER\r\n# unmount the project\r\ndiskutil unmount force ~/$LOCAL\r\nosascript -e &amp;#39;quit app &amp;quot;Terminal&amp;quot;&amp;#39; &amp;amp; exit 0\r\n&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;kill-grunt.expect&lt;/strong&gt;\r\nThis one is called by unmount.command. It ends any grunt processes running on the server.&lt;/p&gt;\r\n&lt;pre&gt;&lt;code&gt;#!/usr/bin/expect\r\nset HOST [lindex $argv 0]\r\nset USER [lindex $argv 1]\r\nspawn ssh $USER@$HOST\r\nexpect &amp;quot;$ &amp;quot; {\r\n    send &amp;quot;sudo killall grunt\\r&amp;quot;\r\n    expect &amp;quot;$ &amp;quot; { exit }\r\n}\r\n&lt;/code&gt;&lt;/pre&gt;","date":"Sat Oct 10 2015"}}